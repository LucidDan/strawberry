---
title: Channels
---

# Channels

Strawberry provides support for [Channels](https://channels.readthedocs.io/)
with
[Consumers](https://channels.readthedocs.io/en/stable/topics/consumers.html) to
provide GraphQL support over WebSockets and HTTP.

## Introduction

While Channels does require Django to be installed as a dependency, you can
actually run this integration without using Django's request handler. However,
the most common use case will be to run a normal Django project with GraphQL
subscriptions support, typically taking advantage of the Channel Layers
functionality which is exposed through the Strawberry integration.

---

## Getting Started

### Pre-requisites

Make sure you have read the following Channels documentation:

- [Introduction](https://channels.readthedocs.io/en/stable/introduction.html#)
- [Tutorial](https://channels.readthedocs.io/en/stable/tutorial/index.html)
- [Consumers](https://channels.readthedocs.io/en/stable/topics/consumers.html)
- And our [Subscriptions](../general/subscriptions) documentation.

If you have read the Channels documentation, You should know by now that:

- ASGI application is a callable function that can handle multiple send / receive operations
  without the need of a new application instance.

- Channels is all about making ASGI applications instances
  (whether in another processes or in another machine)
  Talk to each other seamlessly.
- A `scope` is a single connection represented by a dict, Whether
  it would be a websocket or an HTTP request or another protocol.
- A `Consumer` is an ASGI application abstraction, That helps to handle a single scope.
  Before using Strawberry's Channels support, make sure you install all the
  required dependencies by running:

### Installation

```
pip install 'strawberry-graphql[channels]'
```

---

## Tutorial

_The following example will pick up where part 3 of the Channels tutorial left off._

By the end of This tutorial, You will have a graphql chat subscription that will be able to talk
with the channels chat consumer from the tutorial.

### Types setup

First, Let's create some Strawberry-types for the chat.

```python
# mysite/gqlchat/subscription.py

@strawberry.input
class ChatRoom:
    room_name: str


@strawberry.type
class ChatRoomMessage:
    room_name: str
    current_user: str
    message: str

```

### Channel Layers

The Context for Channels integration includes the consumer, which has an
instance of the channel layer and the consumer's channel name. Here's an example
of how this can be used in the schema to provide subscriptions to events
generated by background tasks or the web server, even if these are executed in
other threads, processes, or even other servers if you are using a Layer backend
like Redis or RabbitMQ.

To set this up, you'll need to make sure Channel Layers is configured as per the
[documentation](https://channels.readthedocs.io/en/stable/topics/channel_layers.html).

Then you'll want to add a subscription that accesses the channel layer and joins
one or more broadcast groups.

Since listening for events and passing them along to the client is a common use case,
the base consumer provides a high level API for that using a generator pattern.

### The chat subscription

Now we will create the chat [subscription](../general/subscriptions.md).

```python
# mysite/gqlchat/subscription.py

@strawberry.type
class Subscription:
    @strawberry.subscription
    async def join_chat_rooms(
        self,
        info: Info,
        rooms: List[ChatRoom],
        user: str,
    ) -> AsyncGenerator[ChatRoomMessage, None]:
        """Join and subscribe to message sent to the given rooms."""
        ws = info.context.ws
        channel_layer = ws.channel_layer
        for room in (rooms := ["chat_%s" % room.room_name for room in rooms]):
            # Join room group
            await channel_layer.group_add(room, ws.channel_name)

        for room in rooms:
            await channel_layer.group_send(
                room,
                {
                    "type": "chat.message",
                    "room_id": room,
                    "message": f"process: {os.getpid()} thread: {threading.current_thread().name}"
                    f" -> Hello my name is {user}!",
                },
            )

        async for message in ws.channel_listen("chat.message", groups=rooms):
            yield ChatRoomMessage(
                room_name=message["room_id"], message=message["message"], current_user=user
            )

```

Explanation:
`Info.context.ws` or `Info.context.request` is a pointer to the
[`ChannelsConsumer`](#channelsconsumer) instance.
Here we have first sent a message to all
the channel_layer groups (specified in the subscription argument `rooms`)
that we have joined the chat.

<Note>

We do not need to call `await channel_layer.group_add(room, ws.channel_name)`
If we don't want to send an initial message while instantiating the subscription.
It is handled by `ws.channel_listen`.

</Note>

### Chat message mutation

If you noticed, the subscription client can't send a message willingly. You will have to
create a mutation for sending messages via the `channel_layer`

```python
# mysite/gqlchat/subscription.py

class Mutation:
    @strawberry.mutation
    async def send_chat_message(
        self,
        room: ChatRoom,
        message: str,
    ) -> None:
        channel_layer = get_channel_layer()
        await channel_layer.group_send(
            f"chat_{room.room_name}",
            {
                "type": "chat.message",
                "room_id": room.room_name,
                "message": message,
            },
        )
```

### Creating the consumers

All we did so far is useless without creating an asgi consumer for our schema.
The easiest way to do that is to use the [`GraphQLProtocolTypeRouter`](#graphqlprotocoltyperouter)
which will wrap your Django application, and route
**HTTP and websockets** for /graphql to Strawberry, while sending all other requests
to Django. You'll need to modify the `myproject.asgi.py` file from the Channels
instructions to look something like this:

```python
import os

from django.core.asgi import get_asgi_application
from strawberry.channels import GraphQLProtocolTypeRouter

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mysite.settings')
django_asgi_app = get_asgi_application()

# Import your Strawberry schema after creating the django ASGI application
# This ensures django.setup() has been called before any ORM models are imported
# for the schema.
from mysite.graphql import schema


application = GraphQLProtocolTypeRouter(
    schema,
    django_application=django_asgi_app,
)
```

This approach is not very flexible, taking away some useful capabilities
of Channels. For more complex deployments,
i.e you want to integrate several ASGI applications
on different URLs and protocols, like what is described in the
[Channels documentation](https://channels.readthedocs.io/en/stable/topics/protocols.html).
You will probably craft your own
[`ProtocolTypeRouter`](https://channels.readthedocs.io/en/stable/topics/routing.html#protocoltyperouter).

An example of this (continuing from channels tutorial) would be:

```python
from channels.auth import AuthMiddlewareStack
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.security.websocket import AllowedHostsOriginValidator
from django.core.asgi import get_asgi_application
from django.urls import re_path
from strawberry.channels import GraphQLHTTPConsumer
from strawberry.channels import GraphQLWSConsumer

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mysite.settings')
django_asgi_app = get_asgi_application()
# Import your Strawberry schema after creating the django ASGI application
# This ensures django.setup() has been called before any ORM models are imported
# for the schema.

from mysite.chat import routing
from mysite.graphql import schema

websocket_urlpatterns = routing.websocket_urlpatterns + \
                        [re_path(r"graphql", GraphQLWSConsumer.as_asgi(schema=schema)), ]



gql_http_consumer = AuthMiddlewareStack(GraphQLHTTPConsumer.as_asgi(schema=schema))
gql_ws_consumer = GraphQLWSConsumer.as_asgi(schema=schema)
application = ProtocolTypeRouter(
    {
        "http": URLRouter(
            [
                re_path("^graphql", gql_http_consumer),
                re_path("^", django_asgi_app),  # This might be another endpoints in your app
            ]
        ),
        "websocket": AllowedHostsOriginValidator(
            AuthMiddlewareStack(URLRouter(websocket_urlpatterns))
        ),
    }
)

```

This example demonstrates some ways that Channels can be set up to handle
routing. A very common scenario will be that you want user and session
information inside the GraphQL context, which the AuthMiddlewareStack wrapper
above will provide. It might be apparent by now, there's no reason at all why
you couldn't run a Channels server without any Django ASGI application at all.
However, take care to ensure you run `django.setup()` instead of
`get_asgi_application()`, if you need any Django ORM or other Django features in
Strawberry.

Look here for some much more complete examples:

1. The
   [Strawberry Examples repo](https://github.com/strawberry-graphql/examples)
   contains a basic example app demonstrating subscriptions with Channels.

---

## Testing

To test our chat app we can use the Channels [`ApplicationCommunicator`](https://channels.readthedocs.io/en/stable/topics/testing.html#applicationcommunicator).

---

## References

### GraphQLProtocolTypeRouter

A helper for creating a common strawberry-django
[`ProtocolTypeRouter`](https://channels.readthedocs.io/en/stable/topics/routing.html#protocoltyperouter)
Implementation.

Example usage:

```
from strawberry.channels import GraphQLProtocolTypeRouter
from django.core.asgi import get_asgi_application

django_asgi = get_asgi_application()

from myapi import schema

application = GraphQLProtocolTypeRouter(
    schema,
    django_application=django_asgi,
)
```

This will route all requests to /graphql on either HTTP or websockets to us,
and everything else to the Django application.

### ChannelsConsumer

Strawberries extended [`AsyncConsumer`](https://channels.readthedocs.io/en/stable/topics/consumers.html#consumers).

**Every graphql session will have an instance of this class inside
`info.ws` which is actually the `info.context.request`.**

The [`ChannelsConsumer`](#channelsconsumer) have some helpers like
`headers` that returns a map of the headers from `scope['headers']`,
It also overrides the `dispatch` method of channels
[`AsyncConsumer`](https://channels.readthedocs.io/en/stable/topics/consumers.html#consumers)
and if your `scope` type is `http.*` or `websocket.*` it will be appended to a relevant`asyncio.Queue`,
later to be used by
`ws.channel_listen` AsyncGenerator, accepts a list of groups to yield messages from.
